namespace UnitTests;

public class MergeComments
{
	[Fact]
	public void TestMergeComments()
	{
		const string source = @"
		    public static string MergeComments(string source, string generated)
			{
				int generated_index = 0;

				foreach (var source_line in source_line_list)
				{
					while (generated_index < generated_line_list.Length && comment_regex.IsMatch(generated_line_list[generated_index]))
					{
						result.Add(generated_line_list[generated_index]);
						generated_index++;
					}

					result.Add(source_line);

					if (generated_index < generated_line_list.Length 
						&& code_regex.IsMatch(generated_line_list[generated_index]) 
						&& source_line.Trim() == generated_line_list[generated_index].Trim())
					{
						generated_index++; // Advance in generated only if the lines of code are similar
					}
					else if (generated_index < generated_line_list.Length 
							&& code_regex.IsMatch(generated_line_list[generated_index])
							&& source_line.Trim() != generated_line_list[generated_index].Trim())
					{
						// Missing comment in generated by hallucination
						generated_index++;
					}
				}

				return string.Join(Environment.NewLine, result);
			}
		";

		const string generated = @"
		    public static string MergeComments(string source, string generated)
			{
				// Comment 1
				int generated_index = 0;

				// Comment generated by hallucination
				if (hallucinated_statement)
				{
					return(false);
				}

				// Comment 2.0
				// Comment 2.1
				// Comment 2.2
				foreach (var source_line in source_line_list)
				{
					// Comment 3.0
					while (generated_index < generated_line_list.Length && comment_regex.IsMatch(generated_line_list[generated_index]))
					{
						result.Add(generated_line_list[generated_index]);
						generated_index++;
					}

					// Comment generated by hallucination
					if (hallucinated_statement)
					{
						return(false);
					}
					  

					// Statement commented by hallucination
					//result.Add(source_line);
					                                       
					// Some code is missing here, because of hallucination														   
					else if (generated_index < generated_line_list.Length 
							&& code_regex.IsMatch(generated_line_list[generated_index])
							&& source_line.Trim() != generated_line_list[generated_index].Trim())
					{
						generated_index++;
					}
				}

				// Comment 4.0
				return string.Join(Environment.NewLine, result);
			}
		";

		const string expected = @"
		    public static string MergeComments(string source, string generated)
			{
				// Comment 1
				int generated_index = 0;

				// Comment 2.0
				// Comment 2.1
				// Comment 2.2
				foreach (var source_line in source_line_list)
				{
					// Comment 3.0
					while (generated_index < generated_line_list.Length && comment_regex.IsMatch(generated_line_list[generated_index]))
					{
						result.Add(generated_line_list[generated_index]);
						generated_index++;
					}

					result.Add(source_line);

					if (generated_index < generated_line_list.Length 
						&& code_regex.IsMatch(generated_line_list[generated_index]) 
						&& source_line.Trim() == generated_line_list[generated_index].Trim())
					{
						generated_index++; // Advance in generated only if the lines of code are similar
					}
					else if (generated_index < generated_line_list.Length 
							&& code_regex.IsMatch(generated_line_list[generated_index])
							&& source_line.Trim() != generated_line_list[generated_index].Trim())
					{
						// Missing comment in generated by hallucination
						generated_index++;
					}
				}

				// Comment 4.0
				return string.Join(Environment.NewLine, result);
			}
		";

		var result = Utilities.MergeComments(source, generated);

		string expected_os_normalized = expected.Replace("\r\n", "\n").Replace("\n", "");
		string result_os_normalized = result.Replace("\r\n", "\n").Replace("\n", "");		

		Assert.Equal(expected_os_normalized, result_os_normalized);
	}


}